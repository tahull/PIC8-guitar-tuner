/* main for guitar tuner project
 * implements AMDF autocorrelation or IIR to find pitch/frequency
 * code in "MCC Generated Files" folder is generated by MCC code configurator and
 * subject to microchip license see mcc.h
 */

#include "mcc_generated_files/mcc.h"
#include "tuner_defs.h"
#include "tuner_display.h"


//global vars
#if (TUNER_MODE == AMDF || defined RAW_SIGNAL_DEBUG)
#include "amdf.h"
samp_t sample_buff[SAMPLE_SIZE] = { 0 }; //samples from adc
#endif
#if TUNER_MODE == IIR 
volatile samp_t sample;
#endif
enum tuner {SCAN,COLLECT,PROCESS,PAUSE} tuner_state; //sampling states

//function prototypes
adc_t ADC_read(void);
#ifdef RAW_SIGNAL_DEBUG
void print_array(uint16_t len, samp_t *arr);
#endif

#if TUNER_MODE == IIR
int16_t a1 = -433, a2 = 210, b0 = 20, b1 = -22, b2 = 20; // fc = 370 hz
static inline int16_t iir_df1(int16_t x0){
    static int16_t x1,x2,y1,y2;
    int32_t yn;
    
    yn = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;
    yn >>= 8;
    x2 = x1;
    x1 = x0;
    y2 = y1;
    y1 = (int16_t)yn;
    return (int16_t)yn;
}

static inline uint16_t zc(int16_t yn){
    static uint16_t avg_cnt, cnt, point, accum;
    static int16_t a,b;
    uint16_t avg = 0;    

    b = a;
    a = yn;
    //find some amount of crossings
    if(avg_cnt < 15){
        //count difference between zero crossings
        if(a >= 0 && b < 0){
            if(point > 0){
                accum += cnt - point;
                avg_cnt++;
            }
            //found a crossing point
            point = cnt; 
        }
        cnt++;        
    }
    //
    else{
        //shift up for better accuracy
        avg = (uint16_t)(((uint32_t)accum<<5)/avg_cnt);
#ifdef ZC_DEBUG
        printf("accum: %u crossings: %u avg: %u \n", accum, avg_cnt, avg);
#endif        
        avg_cnt = 0;
        accum = 0;
        cnt = 0;            
        point = 0;            
    }
    return avg;
}

//1) try to determine approximate frequency of raw signal harmonics and all
//2) set coefficients for filter, filter signal
//3) determine frequency of filtered (cleaned up) signal
uint16_t iir_process(int16_t raw_val){
    int16_t yn;
    uint16_t f = 0, avg = 0;
    
    //2 filter
    yn = iir_df1(raw_val);
    //3 find average period
    avg = zc(yn);
    
    //move decimal point to 1/10 place
    if(avg != 0){
        f = (uint16_t)((((uint32_t)FS*10)<<5)/avg);
    }
    return f;
}
#endif

/* Timer interrupt for adc sample frequency     
 */
void TMR0_Interrupt(void){
    static uint16_t idx;
    static adc_t adc_val;

    adc_val = ADC_read();
    
    // found a loud signal, is if from a guitar?, does it matter?
    // TODO: test if it's worth additional testing, like checking for a second
    // peak and checking if the period falls in an expected range
    if (tuner_state == SCAN && adc_val > TRIGGER_LEVEL)
        tuner_state = COLLECT;
    if (tuner_state == COLLECT){
#if TUNER_MODE == AMDF
        //collect samples, then process the buffer
        if(idx < SAMPLE_SIZE){
            sample_buff[idx] = adc_val - ADCOFFSET;
            idx++;
        }
        else{
            idx = 0;
            tuner_state = PROCESS;
        }
#else
        //process every sample
        sample = (samp_t)(adc_val - ADCOFFSET);
        tuner_state = PROCESS;        
#endif
        
    }
}

/* read adc, using this rather than mcc's ADC_GetConversion(adc_channel_t channel)
 * function. Since this project is using one adc channel 
 * and doesn't switch the channel on/off, it doesn't need acq delay
 * 
 * Allow selecting adc bit resolution 1-16, this mcu is up to 10 bit resolution
 * support for sub 3 bit and above 10 bit is here just for implementing in a 
 * generalized form although pointless.
 * 
 * Assumes ADC result is left justified
 */
adc_t ADC_read(void){
    // Start the conversion
    ADCON0bits.GO_nDONE = 1;
    // Wait for the conversion to finish. (adc 1/64 prescale ~30uS)(1/32 prescale ~12uS)
    while (ADCON0bits.GO_nDONE);
    // Conversion finished, return the result
#if ADCBITS > 8
    return (((uint16_t)(ADRESH << 8) + ADRESL)>>(16-ADCBITS));
#else
    return ADRESH >> (8-ADCBITS); 
#endif
}

/* Print the sample array
 */
#ifdef RAW_SIGNAL_DEBUG
void print_array(uint16_t len, samp_t *arr){
    printf("orig_signal = [");
    for(uint16_t i = 0; i < len; i++ )
        if(i == len-1) // last item. no comma
            printf("%i",arr[i]);
        else
            printf("%i,",arr[i]);
    printf("]\n");
}
#endif


/*
                         Main application
 */
void main(void)
{
    // initialize the device
    SYSTEM_Initialize();

    // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
    // Use the following macros to:

    // Enable the Global Interrupts
    INTERRUPT_GlobalInterruptEnable();

    // Enable the Peripheral Interrupts
    //INTERRUPT_PeripheralInterruptEnable();

    // Disable the Global Interrupts
    //INTERRUPT_GlobalInterruptDisable();

    // Disable the Peripheral Interrupts
    //INTERRUPT_PeripheralInterruptDisable();
    
    TMR0_SetInterruptHandler(TMR0_Interrupt);
    ADC_SelectChannel(channel_AN11);
#ifdef RAW_SIGNAL_DEBUG
    printf("adc offset: %d adc trigger: %d \n", ADCOFFSET, TRIGGER_LEVEL);    
    printf("min limit: %d max limit: %d \n", T_MIN, T_MAX);
#endif  
    
    while (1)
    {
        if(tuner_state == PROCESS){
            //INTERRUPT_GlobalInterruptDisable();
            uint16_t f = 0;                       
            
#if TUNER_MODE == AMDF
            INTERRUPT_GlobalInterruptDisable();
            tuner_state = PAUSE; 
            f = amdf(SAMPLE_SIZE, sample_buff, FS);
            INTERRUPT_GlobalInterruptEnable();
#else
            tuner_state = COLLECT;
            f = iir_process(sample);
#endif
            
            //found a frequency pause adc and display tuning
            if(f != 0){
                INTERRUPT_GlobalInterruptDisable();
#ifdef RAW_SIGNAL_DEBUG
                //print the original array
                printf("freq: %u.%u\n",(uint16_t)(f/10),(uint16_t)(f%10));
                //print_array(SAMPLE_SIZE, sample_buff);
                printf("freq: %u.%u\n",(uint16_t)(f/10),(uint16_t)(f%10));
#endif
                tuner_display(f);
                tuner_state = SCAN;
                INTERRUPT_GlobalInterruptEnable();
            }
            //INTERRUPT_GlobalInterruptEnable();
        }
    }
}
/**
 End of File
*/
